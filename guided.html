<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>心理ゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse-ring {
            0% { transform: scale(.8); opacity: 0; }
            100% { transform: scale(1.3); opacity: 0; }
        }
        @keyframes pulse-dot {
            0% { transform: scale(.8); }
            50% { transform: scale(1); }
            100% { transform: scale(.8); }
        }
        .recording-animation::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #ef4444;
            animation: pulse-ring 1.25s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }
        .recording-dot {
            animation: pulse-dot 1.25s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
        }
        .disabled-btn {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-green-100 to-blue-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-green-800 mb-2">心理ゲーム</h1>
            <p class="text-gray-600">キャラクターと一緒に心理ゲームに挑戦</p>
            <a href="/" class="inline-block mt-4 px-4 py-2 bg-gray-600 text-white text-sm rounded-md hover:bg-gray-700 transition-colors">
                ホームに戻る
            </a>
        </header>

        <!-- Main Content -->
        <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
            <!-- Game Selection -->
            <div class="p-6 border-b border-gray-200">
                <div class="grid grid-cols-1 gap-6">
                    <!-- Game Selection -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ゲーム選択</label>
                        <select id="game-select" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-green-500">
                            <option value="prisoners-dilemma">二人の選択</option>
                            <option value="desert-island">無人島の持ち物</option>
                            <option value="magic-choice">魔法の力</option>
                        </select>
                    </div>
                    
                    <!-- Character Info Display (read-only) -->
                    <div class="mt-4 p-4 bg-gray-50 rounded-md">
                        <h3 class="text-sm font-medium text-gray-700 mb-2">選択中のキャラクター</h3>
                        <div id="selected-persona-display" class="text-gray-800">
                            <!-- Will be filled by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Hidden Character and Emotion Selects (For internal use) -->
                    <div class="hidden">
                        <select id="character-select">
                            <option value="9">青山龍星</option>
                        </select>
                        <select id="emotion-select">
                            <option value="monotone">モノトーン</option>
                        </select>
                    </div>
                </div>

                <!-- Start Button -->
                <div class="mt-6 text-center">
                    <button id="start-game-btn" class="px-6 py-3 bg-green-600 text-white font-medium rounded-md hover:bg-green-700 transition-colors">
                        ゲームを開始
                    </button>
                </div>
            </div>

            <!-- Game Description -->
            <div id="game-description" class="p-6 bg-gray-50 border-b border-gray-200 hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-2">ゲームの説明</h3>
                <p id="game-description-text" class="text-gray-600"></p>
                <button id="read-description-btn" class="mt-4 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors">
                    <svg class="w-5 h-5 inline-block mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15.536a5 5 0 001.414-5.586m-2.828 9.9a9 9 0 011.414-12.728"></path>
                    </svg>
                    説明を読み上げる
                </button>
            </div>

            <!-- Chat Interface -->
            <div class="p-6">
                <!-- Chat Messages -->
                <div id="chat-messages" class="space-y-4 mb-6 h-96 overflow-y-auto">
                    <!-- Messages will be dynamically added here -->
                </div>

                <!-- Voice Input Controls -->
                <div class="flex items-center justify-center space-x-4">
                    <button id="record-button" class="relative inline-flex items-center justify-center w-16 h-16 rounded-full bg-red-500 hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" disabled>
                        <span class="recording-dot">
                            <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                                <circle cx="10" cy="10" r="6" />
                            </svg>
                        </span>
                    </button>
                </div>

                <!-- Recording Status -->
                <div id="status" class="text-center mt-4 text-sm text-gray-600">
                    録音を開始するにはボタンをクリックしてください
                </div>

                <!-- Game Progress -->
                <div class="mt-8 bg-green-50 rounded-md p-4">
                    <h3 class="text-lg font-medium text-gray-800 mb-2">ゲーム進行状況</h3>
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm text-gray-600">進行段階:</span>
                        <span id="game-stage-counter" class="text-sm font-medium">0 / 5</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="game-progress-bar" class="bg-green-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div class="mt-6 text-right">
                        <button id="end-session-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors disabled-btn" disabled>
                            セッション終了
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Character Description -->
        <div id="character-info" class="mt-8 max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-2">キャラクター情報</h2>
            <div id="character-description" class="text-gray-600">
                キャラクターを選択すると、その説明が表示されます
            </div>
        </div>

        <!-- Self-report Modal (Hidden by default) -->
        <div id="report-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white rounded-lg p-6 max-w-2xl w-full max-h-90vh overflow-y-auto">
                <h2 class="text-xl font-bold text-gray-800 mb-4">ゲーム体験の振り返り</h2>
                
                <!-- System Report Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">システムからのフィードバック</h3>
                    <div id="system-report" class="p-4 bg-gray-50 rounded-md text-gray-800 mb-2">
                        <!-- Will be filled automatically -->
                    </div>
                </div>
                
                <!-- User Report Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">あなたの感想をお聞かせください</h3>
                    <textarea id="user-report" class="w-full p-2 border border-gray-300 rounded-md h-32" placeholder="ゲームの感想、良かった点、改善すべき点などをご自由にお書きください"></textarea>
                </div>
                
                <!-- Detailed Questions Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">詳細な質問</h3>
                    
                    <div class="space-y-4">
                        <!-- Vocabulary Question -->
                        <div>
                            <p class="text-gray-700 mb-1">ゲーム中、普段とは異なる言葉遣いや言い回しをしましたか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="vocabulary" value="simplified" class="form-radio">
                                    <span class="ml-2">はい、簡単な言葉を使った</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="vocabulary" value="normal" class="form-radio" checked>
                                    <span class="ml-2">いいえ、普段通りだった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="vocabulary" value="complex" class="form-radio">
                                    <span class="ml-2">むしろ丁寧に話した</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Expression Ease Question -->
                        <div>
                            <p class="text-gray-700 mb-1">ゲーム中に自分の考えを伝えるのは簡単でしたか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="expression" value="easier" class="form-radio">
                                    <span class="ml-2">人間相手よりも簡単だった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="expression" value="same" class="form-radio" checked>
                                    <span class="ml-2">人間と変わらなかった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="expression" value="harder" class="form-radio">
                                    <span class="ml-2">人間より難しかった</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Confidence Question -->
                        <div>
                            <p class="text-gray-700 mb-1">ロボットと話すとき、自信を持って話せましたか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="confidence" value="more" class="form-radio">
                                    <span class="ml-2">人間より自信を持てた</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="confidence" value="same" class="form-radio" checked>
                                    <span class="ml-2">変わらなかった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="confidence" value="less" class="form-radio">
                                    <span class="ml-2">自信が持てなかった</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Emotional Connection Question -->
                        <div>
                            <p class="text-gray-700 mb-1">ゲーム中にキャラクターとの間に感情的なつながりを感じましたか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="emotion" value="strong" class="form-radio">
                                    <span class="ml-2">強く感じた</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="emotion" value="some" class="form-radio" checked>
                                    <span class="ml-2">少し感じた</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="emotion" value="none" class="form-radio">
                                    <span class="ml-2">感じなかった</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Voice Engagement Question -->
                        <div>
                            <p class="text-gray-700 mb-1">キャラクターの声は会話を続けたいと思わせるものでしたか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="voice_engagement" value="very" class="form-radio">
                                    <span class="ml-2">とても会話を続けたくなった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="voice_engagement" value="somewhat" class="form-radio" checked>
                                    <span class="ml-2">まあまあ続けたくなった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="voice_engagement" value="not" class="form-radio">
                                    <span class="ml-2">あまり続けたくならなかった</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Game Understanding Question -->
                        <div>
                            <p class="text-gray-700 mb-1">ゲームのルールや流れは理解しやすかったですか？</p>
                            <div class="flex items-center space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="game_understanding" value="easy" class="form-radio" checked>
                                    <span class="ml-2">とても理解しやすかった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="game_understanding" value="moderate" class="form-radio">
                                    <span class="ml-2">普通だった</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="game_understanding" value="difficult" class="form-radio">
                                    <span class="ml-2">理解しにくかった</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Rating Section -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-700 mb-2">総合評価</h3>
                    <div class="flex items-center justify-center space-x-2">
                        <span class="text-gray-600">悪い</span>
                        <div class="flex items-center">
                            <input type="radio" id="rating-1" name="rating" value="1" class="hidden peer">
                            <label for="rating-1" class="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white">1</label>
                            
                            <input type="radio" id="rating-2" name="rating" value="2" class="hidden peer">
                            <label for="rating-2" class="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white">2</label>
                            
                            <input type="radio" id="rating-3" name="rating" value="3" class="hidden peer">
                            <label for="rating-3" class="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white">3</label>
                            
                            <input type="radio" id="rating-4" name="rating" value="4" class="hidden peer" checked>
                            <label for="rating-4" class="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white">4</label>
                            
                            <input type="radio" id="rating-5" name="rating" value="5" class="hidden peer">
                            <label for="rating-5" class="w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white">5</label>
                        </div>
                        <span class="text-gray-600">良い</span>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex justify-end space-x-2">
                    <button id="send-report-btn" class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors">送信する</button>
                    <button id="close-modal-btn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors">閉じる</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Character information
        const VOICEVOX_CHARACTERS = {
            1: {
                name: "四国めたん",
                description: "はっきりした芯のある声",
                styles: ["ノーマル", "あまあま", "ツンツン", "セクシー", "ささやき", "ヒソヒソ"]
            },
            2: {
                name: "ずんだもん",
                description: "子供っぽい高めの声",
                styles: ["ノーマル", "あまあま", "ツンツン", "セクシー", "ささやき", "ヒソヒソ", "ヘロヘロ", "なみだめ"]
            },
            3: {
                name: "春日部つむぎ",
                description: "元気な明るい声"
            },
            4: {
                name: "雨晴はう",
                description: "優しく可愛い声"
            },
            7: {
                name: "玄野武宏",
                description: "爽やかな青年の声",
                styles: ["ノーマル", "喜び", "ツンギレ", "悲しみ"]
            },
            8: {
                name: "白上虎太郎",
                description: "声変わり直後の少年の声",
                styles: ["ふつう", "わーい", "おこ", "びくびく", "びえーん"]
            },
            9: {
                name: "青山龍星",
                description: "重厚で低音な声",
                styles: ["ノーマル", "熱血", "不機嫌", "喜び", "しっとり", "かなしみ", "囁き"]
            },
            10: {
                name: "冥鳴ひまり",
                description: "柔らかく温かい声"
            }
        };

        // Game information
        const GAMES = {
            "prisoners-dilemma": {
                title: "二人の選択",
                description: "「二人の選択」は楽しい心理ゲームです。あなたと私は二つの選択肢から一つ選びます。お互いの選択によって結果が変わります。簡単なルールで楽しく遊べますよ。",
                initialPrompt: "こんにちは！「二人の選択」ゲームへようこそ。\n\nとても簡単です。あなたと私が別々に「赤」か「青」を選びます。\n\n選び方によって、こんな結果になります：\n・二人とも「赤」を選ぶと、二人ともプレゼントがもらえます\n・二人とも「青」を選ぶと、小さなプレゼントだけもらえます\n・一人が「赤」、もう一人が「青」を選ぶと、「青」を選んだ人だけ大きなプレゼントがもらえます\n\n「赤」と「青」、どちらを選びますか？お気軽に教えてくださいね。"
            },
            "desert-island": {
                title: "無人島の持ち物",
                description: "「無人島の持ち物」は想像力を使う楽しいゲームです。もし無人島に行くとしたら、何を持っていきますか？あなたの選んだものから、楽しくおしゃべりしましょう。",
                initialPrompt: "こんにちは！「無人島の持ち物」ゲームへようこそ。\n\n想像してみてください。あなたは船に乗っていたら、嵐で無人島に流されてしまいました。そこで1週間過ごすことになりました。\n\n持っていけるのは3つのものだけです。何を持っていきますか？\n\n例えば「ナイフ」「毛布」「マッチ」など、何でも結構です。あなたなら何を選びますか？選んだ理由も教えていただけると嬉しいです。気軽にお話しくださいね。"
            },
            "magic-choice": {
                title: "魔法の力",
                description: "「魔法の力」は夢見るような楽しいゲームです。もしあなたが魔法の力を一つ持てるとしたら、どんな力がいいですか？あなたの願いについて楽しくおしゃべりしましょう。",
                initialPrompt: "こんにちは！「魔法の力」ゲームへようこそ。\n\n想像してみてください。あなたは魔法使いに出会って、一つだけ魔法の力をもらえることになりました。\n\nどんな力がいいですか？例えば：\n1. 目に見えなくなる力\n2. 空を飛べる力\n3. 動物と話せる力\n4. 昔の時代に行ける力\n5. 病気を治せる力\n6. どんな言葉も話せる力\n\nこの中から選んでも、自分で考えた力でも大丈夫です。どんな魔法の力が欲しいですか？その理由も教えていただけると嬉しいです。気軽にお話しくださいね。"
            }
        };

        // Define persona information
        const PERSONAS = {
            "monotone-9": {
                character: "9",
                emotion: "monotone",
                description: "青山龍星: 穏やかでゆっくりと話す声。わかりやすい言葉で、丁寧に話します。"
            },
            "energetic-1": {
                character: "1",
                emotion: "energetic",
                description: "四国めたん: 明るく元気な話し方。親しみやすく、笑顔の感じられる声で話します。"
            },
            "melancholic-8": {
                character: "8",
                emotion: "melancholic",
                description: "白上虎太郎: やさしく寄り添うような話し方。懐かしい言葉も使いながら、ゆっくり話します。"
            }
        };

        // Audio recording setup
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        const recordButton = document.getElementById('record-button');
        const statusDiv = document.getElementById('status');
        const startGameBtn = document.getElementById('start-game-btn');
        const chatMessages = document.getElementById('chat-messages');
        const gameDescriptionDiv = document.getElementById('game-description');
        const gameDescriptionText = document.getElementById('game-description-text');
        const readDescriptionBtn = document.getElementById('read-description-btn');
        const characterDescription = document.getElementById('character-description');
        const characterSelect = document.getElementById('character-select');
        const emotionSelect = document.getElementById('emotion-select');
        const gameSelect = document.getElementById('game-select');
        const selectedPersonaDisplay = document.getElementById('selected-persona-display');

        // Current game state
        let currentGame = null;
        let gameStarted = false;
        let gameStage = 0;
        const MAX_GAME_STAGE = 5;
        const gameStageCounter = document.getElementById('game-stage-counter');
        const gameProgressBar = document.getElementById('game-progress-bar');
        const gameSessionData = {
            startTime: new Date(),
            endTime: null,
            gameType: "",
            gameName: "",
            messageCount: 0,
            userMessages: [],
            botMessages: [],
            currentCharacter: "",
            currentEmotion: "",
            gameStage: 0,
            gameComplete: false,
            interactions: [],
            isComplete: false,
            stagesCompleted: 0
        };
        
        // Load character selection from localStorage
        function loadCharacterFromLocalStorage() {
            const savedPersona = localStorage.getItem('selectedPersona');
            console.log("Loading character from localStorage, saved persona:", savedPersona);
            
            if (savedPersona && PERSONAS[savedPersona]) {
                // Update hidden selects
                const persona = PERSONAS[savedPersona];
                
                // Check if this is the energetic persona and ensure it's using speaker ID 1
                if (savedPersona === "energetic-1") {
                    console.log("Energetic persona detected - explicitly setting to speaker ID 1");
                    characterSelect.value = "1";
                    emotionSelect.value = "energetic";
                } else {
                    characterSelect.value = persona.character;
                    emotionSelect.value = persona.emotion;
                }
                
                // Update displays
                selectedPersonaDisplay.textContent = PERSONAS[savedPersona].description;
                characterDescription.textContent = PERSONAS[savedPersona].description;
                
                console.log("Loaded persona from localStorage:", savedPersona);
                console.log("Set characterSelect to:", characterSelect.value);
                console.log("Set emotionSelect to:", emotionSelect.value);
                
                return true;
            }
            return false;
        }
        
        // Initialize character on page load
        if (!loadCharacterFromLocalStorage()) {
            // If no selection in localStorage, set default
            const defaultPersona = "monotone-9";
            const persona = PERSONAS[defaultPersona];
            characterSelect.value = persona.character;
            emotionSelect.value = persona.emotion;
            selectedPersonaDisplay.textContent = persona.description;
            characterDescription.textContent = persona.description;
            
            console.log("Using default persona:", defaultPersona);
            console.log("Set characterSelect to:", persona.character);
            console.log("Set emotionSelect to:", persona.emotion);
            
            // Save to localStorage to persist
            localStorage.setItem('selectedPersona', defaultPersona);
        }

        // Debug output of current character settings
        console.log("Current character settings at initialization:");
        console.log("- Character select value:", characterSelect.value);
        console.log("- Emotion select value:", emotionSelect.value);
        console.log("- Selected persona from localStorage:", localStorage.getItem('selectedPersona'));

        // Update game description when selection changes
        gameSelect.addEventListener('change', function() {
            const gameKey = this.value;
            const game = GAMES[gameKey];
            if (game) {
                gameDescriptionText.textContent = game.description;
                gameDescriptionDiv.classList.remove('hidden');
            }
        });
        
        // Read description button click handler
        readDescriptionBtn.addEventListener('click', function() {
            const gameKey = gameSelect.value;
            const game = GAMES[gameKey];
            if (game) {
                speakText(game.description);
            }
        });

        // Start game button click handler
        startGameBtn.addEventListener('click', function() {
            if (gameStarted) return;
            
            const gameKey = gameSelect.value;
            currentGame = GAMES[gameKey];
            
            if (currentGame) {
                gameStarted = true;
                gameStage = 0;
                
                // Clear chat messages
                chatMessages.innerHTML = '';
                
                // Add initial game prompt
                addMessage(currentGame.initialPrompt, false);
                
                // Read out the initial prompt
                speakText(currentGame.initialPrompt);
                
                // Disable game selection controls after starting
                gameSelect.disabled = true;
                this.disabled = true;
                this.textContent = 'ゲーム進行中...';
                this.classList.add('bg-gray-500');
                this.classList.remove('bg-green-600', 'hover:bg-green-700');
            }
        });

        // Speech queue to manage sequential speaking
        let speechQueue = [];
        let isSpeaking = false;
        let currentAudio = null;

        // Function to speak text using VOICEVOX
        async function speakText(text) {
            // Add text to speech queue
            speechQueue.push(text);
            console.log("Added text to speech queue. Queue length:", speechQueue.length);
            
            // If not already speaking, start the speech process
            if (!isSpeaking) {
                processNextSpeech();
            }
        }

        // Process the next item in the speech queue
        async function processNextSpeech() {
            if (speechQueue.length === 0) {
                isSpeaking = false;
                currentAudio = null;
                return;
            }
            
            // Cancel any currently playing audio
            if (currentAudio) {
                try {
                    currentAudio.pause();
                    currentAudio = null;
                } catch (err) {
                    console.error("Error stopping current audio:", err);
                }
            }
            
            isSpeaking = true;
            const text = speechQueue.shift();
            
            try {
                console.log("Processing speech:", text);
                
                // Ensure speaker_id and emotion have valid values
                let speaker = characterSelect.value;
                let emotion = emotionSelect.value;
                
                // Set defaults if empty
                if (!speaker || speaker === "") {
                    speaker = "9"; // Default to 青山龍星
                    console.log("Using default speaker_id:", speaker);
                }
                
                if (!emotion || emotion === "") {
                    emotion = "monotone"; // Default to monotone
                    console.log("Using default emotion:", emotion);
                }
                
                // Handle energetic persona specifically
                if (emotion === "energetic") {
                    console.log("Energetic emotion detected - ensuring speaker_id is 1 (四国めたん)");
                    speaker = "1";
                }
                
                console.log("Using speaker_id:", speaker);
                console.log("Using emotion:", emotion);
                
                const formData = new FormData();
                formData.append('text', text);
                formData.append('speaker_id', speaker);
                formData.append('emotion', emotion);
                
                console.log("Sending request to /api/synthesize...");
                const response = await fetch('/api/synthesize', {
                    method: 'POST',
                    body: formData
                });
                
                console.log("Response status:", response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log("Response data:", data);
                    
                    if (data.success) {
                        console.log("Creating audio element with base64 data");
                        const audio = new Audio('data:audio/wav;base64,' + data.audio);
                        currentAudio = audio;
                        
                        // Add event listener for when audio finishes playing
                        audio.addEventListener('ended', () => {
                            console.log("Audio playback finished, processing next speech");
                            currentAudio = null;
                            setTimeout(() => processNextSpeech(), 300); // Small delay between speeches
                        });
                        
                        // Add error handling for audio playback
                        audio.addEventListener('error', (e) => {
                            console.error("Audio playback error:", e);
                            currentAudio = null;
                            setTimeout(() => processNextSpeech(), 300); // Continue with next speech on error
                        });
                        
                        console.log("Playing audio...");
                        try {
                            await audio.play();
                            console.log("Audio playback started");
                        } catch (playError) {
                            console.error("Error starting audio playback:", playError);
                            currentAudio = null;
                            setTimeout(() => processNextSpeech(), 300); // Continue with next speech on error
                        }
                    } else {
                        console.error("Synthesis failed:", data.error);
                        currentAudio = null;
                        setTimeout(() => processNextSpeech(), 300); // Continue with next speech on error
                    }
                } else {
                    console.error("Synthesis request failed with status:", response.status);
                    const errorText = await response.text();
                    console.error("Error details:", errorText);
                    currentAudio = null;
                    setTimeout(() => processNextSpeech(), 300); // Continue with next speech on error
                }
            } catch (err) {
                console.error('Error in processNextSpeech function:', err);
                currentAudio = null;
                setTimeout(() => processNextSpeech(), 300); // Continue with next speech on error
            }
        }

        // Request microphone access
        async function setupAudioRecording() {
            try {
                console.log("Requesting microphone access...");
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log("Microphone access granted, setting up MediaRecorder");
                
                // Check what mimeTypes are supported
                const supportedMimeTypes = [
                    'audio/webm',
                    'audio/webm;codecs=opus',
                    'audio/ogg;codecs=opus'
                ].filter(mimeType => MediaRecorder.isTypeSupported(mimeType));
                
                console.log("Supported MIME types:", supportedMimeTypes);
                
                // Use the first supported MIME type
                const mimeType = supportedMimeTypes[0] || 'audio/webm';
                console.log("Using MIME type:", mimeType);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000
                });
                
                console.log("MediaRecorder initialized with options:", {
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000
                });

                mediaRecorder.ondataavailable = (event) => {
                    console.log("Data available event, chunk size:", event.data.size);
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    console.log("MediaRecorder stopped, processing audio chunks...");
                    console.log("Number of audio chunks:", audioChunks.length);
                    
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    console.log("Created audio blob, size:", audioBlob.size);
                    
                    console.log("Converting to WAV format...");
                    try {
                        const wavBlob = await convertToWav(audioBlob);
                        console.log("WAV conversion complete, size:", wavBlob.size);
                        await processAudioData(wavBlob);
                    } catch (e) {
                        console.error("Error in WAV conversion:", e);
                        statusDiv.textContent = 'WAV変換エラー';
                    }
                };

                // Update UI to show microphone is ready
                statusDiv.textContent = '録音を開始するにはボタンをクリックしてください';
                recordButton.disabled = false;
                console.log("Audio recording setup complete");
            } catch (err) {
                console.error('Error accessing microphone:', err);
                console.error('Error name:', err.name);
                console.error('Error message:', err.message);
                
                statusDiv.textContent = 'マイクにアクセスできません。ブラウザの設定でマイクへのアクセスを許可してください。';
                statusDiv.classList.add('text-red-500', 'font-bold');
                
                // Add a help message with instructions
                const helpDiv = document.createElement('div');
                helpDiv.className = 'mt-4 p-4 bg-yellow-100 text-yellow-800 rounded-md';
                helpDiv.innerHTML = `
                    <h3 class="font-bold">マイクのアクセス方法:</h3>
                    <ul class="list-disc ml-5 mt-2">
                        <li>ブラウザの権限ダイアログで「許可」をクリックしてください</li>
                        <li>アドレスバーの左側にあるアイコンをクリックして、マイクの権限を確認してください</li>
                        <li>ブラウザの設定から、このサイトにマイクの使用を許可してください</li>
                        <li>別のブラウザ（Chrome, Firefox, Edgeなど）を試してみてください</li>
                    </ul>
                `;
                
                // Add a retry button
                const retryButton = document.createElement('button');
                retryButton.className = 'mt-4 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors';
                retryButton.textContent = '再試行';
                retryButton.onclick = () => {
                    location.reload();
                };
                
                const controlsDiv = document.querySelector('.flex.items-center.justify-center');
                controlsDiv.appendChild(retryButton);
                
                document.querySelector('.p-6').appendChild(helpDiv);
                
                // Disable record button
                recordButton.disabled = true;
                recordButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // Convert webm to wav using audio context
        async function convertToWav(webmBlob) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await webmBlob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Create WAV file
            const numberOfChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length * numberOfChannels * 2;
            const buffer = new ArrayBuffer(44 + length);
            const view = new DataView(buffer);
            
            // Write WAV header
            writeUTFBytes(view, 0, 'RIFF');
            view.setUint32(4, 36 + length, true);
            writeUTFBytes(view, 8, 'WAVE');
            writeUTFBytes(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, audioBuffer.sampleRate, true);
            view.setUint32(28, audioBuffer.sampleRate * 2 * numberOfChannels, true);
            view.setUint16(32, numberOfChannels * 2, true);
            view.setUint16(34, 16, true);
            writeUTFBytes(view, 36, 'data');
            view.setUint32(40, length, true);

            // Write audio data
            const floatArray = audioBuffer.getChannelData(0);
            let offset = 44;
            for (let i = 0; i < floatArray.length; i++) {
                const sample = Math.max(-1, Math.min(1, floatArray[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeUTFBytes(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Function to create a more interactive processAudioData
        async function processAudioData(audioBlob) {
            statusDiv.textContent = '処理中...';
            console.log("processAudioData called with blob size:", audioBlob.size);

            if (!gameStarted || !currentGame) {
                statusDiv.textContent = 'ゲームを開始してください';
                console.warn("Game not started yet. Aborting audio processing.");
                return;
            }

            // Check if audio is too small (likely silent or too short)
            if (audioBlob.size < 10000) {
                statusDiv.textContent = '録音が短すぎるか、音声が検出されませんでした。もう一度お試しください。';
                setTimeout(() => {
                    statusDiv.textContent = '録音を開始するにはボタンをクリックしてください';
                }, 3000);
                return;
            }

            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.wav');
            
            // Get current speaker_id and emotion values directly from select elements
            const speaker = characterSelect.value;
            const emotion = emotionSelect.value;
            
            // Special handling for energetic emotion - make sure we're using 四国めたん (ID 1)
            let finalSpeakerId = speaker;
            if (emotion === "energetic") {
                console.log("Energetic emotion detected - using speaker_id 1 (四国めたん)");
                finalSpeakerId = "1";
            }
            
            // Log the values we're sending
            console.log("Sending speaker_id:", finalSpeakerId);
            console.log("Sending emotion:", emotion);
            
            formData.append('speaker_id', finalSpeakerId);
            formData.append('emotion', emotion);
            
            // Add game context for the AI with simplified focus on conversation
            formData.append('game_type', gameSelect.value);
            formData.append('game_stage', gameStage);
            formData.append('context', currentGame.title + "（楽しい会話）");
            
            console.log("FormData prepared with:");
            console.log("- speaker_id:", finalSpeakerId);
            console.log("- emotion:", emotion);
            console.log("- game_type:", gameSelect.value);
            console.log("- game_stage:", gameStage);
            console.log("- context:", currentGame.title + "（楽しい会話）");

            try {
                console.log("Sending audio to /api/process-game...");
                const response = await fetch('/api/process-game', {
                    method: 'POST',
                    body: formData
                });
                
                console.log("Response status:", response.status);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Server error response:", errorData);
                    
                    // Show error message to user
                    statusDiv.textContent = errorData.error || 'サーバーエラー: ' + response.status;
                    statusDiv.classList.add('text-red-500');
                    
                    // Reset status after a delay
                    setTimeout(() => {
                        statusDiv.textContent = '録音を開始するにはボタンをクリックしてください';
                        statusDiv.classList.remove('text-red-500');
                    }, 5000);
                    
                    return;
                }

                const data = await response.json();
                console.log("Response data received:", data);
                
                if (data.success) {
                    console.log("Successfully processed audio");
                    console.log("User text:", data.user_text);
                    console.log("Bot response:", data.bot_response);
                    
                    // Add messages to chat
                    addMessage(data.user_text, true);
                    addMessage(data.bot_response, false);

                    // Play the response audio
                    console.log("Playing response audio...");
                    const audio = new Audio('data:audio/wav;base64,' + data.audio);
                    await audio.play();

                    // Store interaction data
                    const interactionData = {
                        timestamp: new Date().toISOString(),
                        gameType: gameSelect.value,
                        gameName: currentGame ? currentGame.title : "",
                        gameStage: gameStage,
                        userMessage: data.user_text,
                        botResponse: data.bot_response,
                        character: gameSessionData.currentCharacter,
                        emotion: gameSessionData.currentEmotion
                    };
                    
                    // Add to interactions array
                    gameSessionData.interactions.push(interactionData);
                    
                    // Store in localStorage (temporary storage)
                    try {
                        // Get existing session data or initialize empty array
                        let allGameData = JSON.parse(localStorage.getItem('voicevox_game_data') || '[]');
                        allGameData.push(interactionData);
                        localStorage.setItem('voicevox_game_data', JSON.stringify(allGameData));
                        console.log("Game data stored in localStorage");
                    } catch (err) {
                        console.error('Error storing game data:', err);
                    }

                    // Increment game stage but limit to preserve conversation
                    if (gameStage < MAX_GAME_STAGE) {
                        gameStage++;
                        updateGameProgressUI();
                        console.log("Game stage incremented to:", gameStage);
                    }
                    
                    // Check if game should continue or end
                    if (data.game_complete || gameStage >= MAX_GAME_STAGE) {
                        gameSessionData.isComplete = true;
                        updateGameProgressUI();
                        console.log("Game marked as complete");
                        
                        // Clear any remaining speech in the queue
                        speechQueue = [];
                        if (currentAudio) {
                            try {
                                currentAudio.pause();
                                currentAudio = null;
                            } catch (err) {
                                console.error("Error stopping current audio:", err);
                            }
                            isSpeaking = false;
                        }
                        
                        // Add a friendly ending after some time
                        setTimeout(() => {
                            const endingMessage = "とても楽しいお話をありがとうございました！ゲームが完了しました。振り返りボタンをクリックして、アンケートにご協力ください。";
                            addMessage(endingMessage, false);
                            speakText(endingMessage);
                        }, 2000);
                    }
                } else {
                    statusDiv.textContent = 'エラー: ' + data.error;
                    console.error('Server error:', data.error);
                }
            } catch (err) {
                console.error('Error processing audio:', err);
                console.error('Error details:', err.message);
                statusDiv.textContent = '音声処理エラー';
            }

            statusDiv.textContent = '録音を開始するにはボタンをクリックしてください';
        }

        // Function to update progress UI
        function updateGameProgressUI() {
            // Update stage counter
            gameStageCounter.textContent = `${gameStage} / ${MAX_GAME_STAGE}`;
            
            // Calculate progress percentage
            const progress = (gameStage / MAX_GAME_STAGE) * 100;
            gameProgressBar.style.width = `${progress}%`;
            
            // Update session data
            gameSessionData.stagesCompleted = gameStage;
            gameSessionData.isComplete = gameStage >= MAX_GAME_STAGE;
            
            // Enable or disable end session button based on completion
            endSessionBtn.disabled = !gameSessionData.isComplete;
            endSessionBtn.classList.toggle('bg-gray-500', !gameSessionData.isComplete);
            endSessionBtn.classList.toggle('bg-green-500', gameSessionData.isComplete);
            
            if (gameSessionData.isComplete) {
                endSessionBtn.textContent = 'ゲーム完了 - 振り返りを行う';
            }
        }

        // Reset game state with friendly message
        function resetGame() {
            gameStarted = false;
            currentGame = null;
            gameStage = 0;
            
            // Re-enable game selection controls
            gameSelect.disabled = false;
            startGameBtn.disabled = false;
            startGameBtn.textContent = 'ゲームを開始';
            startGameBtn.classList.remove('bg-gray-500');
            startGameBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            
            // Add game completion message
            const completionMessage = "また新しいゲームを選んで「ゲームを開始」ボタンを押してくださいね。";
            addMessage(completionMessage, false);
            
            // Read out the completion message
            speakText(completionMessage);
        }

        // Initialize audio recording
        setupAudioRecording();

        // End session button functionality
        const endSessionBtn = document.getElementById('end-session-btn');
        const reportModal = document.getElementById('report-modal');
        const systemReport = document.getElementById('system-report');
        const userReport = document.getElementById('user-report');
        const sendReportBtn = document.getElementById('send-report-btn');
        const closeModalBtn = document.getElementById('close-modal-btn');
        
        // Update the original addMessage function to track messages
        const originalAddMessage = addMessage;
        addMessage = function(text, isUser = false) {
            originalAddMessage(text, isUser);
            
            // Track message
            gameSessionData.messageCount++;
            if (isUser) {
                gameSessionData.userMessages.push(text);
            } else {
                gameSessionData.botMessages.push(text);
            }
            
            // Update character info if not already set
            if (!gameSessionData.currentCharacter) {
                const charId = characterSelect.value;
                const character = VOICEVOX_CHARACTERS[charId];
                gameSessionData.currentCharacter = character ? character.name : "不明";
                
                const emotionKey = emotionSelect.value;
                let emotionName = "標準";
                if (emotionKey === "monotone") emotionName = "穏やか";
                if (emotionKey === "energetic") emotionName = "元気";
                if (emotionKey === "melancholic") emotionName = "物思い";
                gameSessionData.currentEmotion = emotionName;
            }
            
            // Update progress UI
            updateGameProgressUI();
        };
        
        // Update game session data when game is selected or started
        gameSelect.addEventListener('change', function() {
            const gameKey = this.value;
            const game = GAMES[gameKey];
            if (game) {
                gameSessionData.gameType = gameKey;
                gameSessionData.gameName = game.title;
            }
        });
        
        startGameBtn.addEventListener('click', function() {
            gameSessionData.startTime = new Date(); // Reset start time when game actually starts
        });
        
        // Generate system report based on game session
        function generateGameReport() {
            gameSessionData.endTime = new Date();
            const duration = Math.round((gameSessionData.endTime - gameSessionData.startTime) / 60000); // minutes
            
            // Game completion status
            let completionStatus = "途中";
            if (gameSessionData.gameComplete || gameStage >= MAX_GAME_STAGE) {
                completionStatus = "完了";
            } else if (gameSessionData.messageCount < 4) {
                completionStatus = "初期段階";
            }
            
            // Interaction assessment
            let interactionQuality = "標準的";
            if (gameSessionData.messageCount > 12) {
                interactionQuality = "非常に活発";
            } else if (gameSessionData.messageCount > 8) {
                interactionQuality = "活発";
            } else if (gameSessionData.messageCount < 4) {
                interactionQuality = "限定的";
            }
            
            // User engagement
            let userEngagement = "普通";
            if (gameSessionData.userMessages.length > 0) {
                const avgUserLength = gameSessionData.userMessages.join('').length / gameSessionData.userMessages.length;
                if (avgUserLength > 30) {
                    userEngagement = "非常に積極的";
                } else if (avgUserLength > 15) {
                    userEngagement = "積極的";
                } else if (avgUserLength < 8) {
                    userEngagement = "控えめ";
                }
            }
            
            // Calculate words per minute (approximate)
            let wpm = "測定不能";
            if (gameSessionData.userMessages.length > 0 && duration > 0) {
                // Approximate Japanese word count by counting characters and dividing by 2
                const totalChars = gameSessionData.userMessages.join('').length;
                const approxWords = Math.round(totalChars / 2);
                wpm = Math.round(approxWords / duration);
            }
            
            // Estimate lexical complexity
            let lexicalComplexity = "標準";
            if (gameSessionData.userMessages.length > 0) {
                const allText = gameSessionData.userMessages.join(' ');
                
                // Check for complex grammar patterns (approximate method)
                const hasKeigo = /でございます|いたします|になります|ございます/.test(allText);
                const hasComplexSentences = /ならば|であれば|としても|にもかかわらず|ものの|ゆえに/.test(allText);
                const hasLongSentences = gameSessionData.userMessages.some(msg => msg.length > 50);
                
                if (hasKeigo || hasComplexSentences || hasLongSentences) {
                    lexicalComplexity = "高度";
                } else if (allText.length < 100 && gameSessionData.userMessages.length > 3) {
                    lexicalComplexity = "単純";
                }
            }
            
            // Create report
            return `
心理ゲームセッションレポート (${new Date().toLocaleDateString()}):

■ 基本情報
・ゲーム名: ${gameSessionData.gameName || "不明"}
・使用キャラクター: ${gameSessionData.currentCharacter} (${gameSessionData.currentEmotion}調)
・セッション時間: 約${duration}分
・会話の往復回数: ${Math.floor(gameSessionData.messageCount/2)}回

■ ゲーム分析
・完了状態: ${completionStatus}
・会話の流れ: ${interactionQuality}
・ユーザー参加度: ${userEngagement}

■ 言語指標
・推定発話速度: ${wpm} 語/分
・語彙の複雑さ: ${lexicalComplexity}
・平均応答長: ${gameSessionData.userMessages.length > 0 
    ? Math.round(gameSessionData.userMessages.join('').length / gameSessionData.userMessages.length) + "文字" 
    : "測定不能"}

■ 総合評価
${gameSessionData.gameName}のゲームセッションは${completionStatus === "完了" ? "最後まで行われ" : "途中まで行われ"}ました。
対話は${interactionQuality}で、ユーザーの参加度は${userEngagement}でした。
${completionStatus === "完了" ? "完全なゲーム体験を提供できました。" : "次回はぜひ最後まで体験してみてください。"}
${userEngagement === "非常に積極的" ? "積極的なご参加、ありがとうございました。" : "また別のゲームもお試しください。"}
`;
        }
        
        // End session button click handler
        endSessionBtn.addEventListener('click', function() {
            // Only allow ending if game is completed
            if (!gameSessionData.isComplete) {
                alert('まだゲームが完了していません。ゲームを最後まで進めてください。');
                return;
            }
            
            // Generate system report
            const report = generateGameReport();
            systemReport.textContent = report;
            
            // Show modal
            reportModal.classList.remove('hidden');
        });
        
        // Close modal button
        closeModalBtn.addEventListener('click', function() {
            reportModal.classList.add('hidden');
        });
        
        // Send report button
        sendReportBtn.addEventListener('click', async function() {
            // Get user's rating
            const rating = document.querySelector('input[name="rating"]:checked').value;
            
            // Get detailed question responses
            const vocabulary = document.querySelector('input[name="vocabulary"]:checked').value;
            const expression = document.querySelector('input[name="expression"]:checked').value;
            const confidence = document.querySelector('input[name="confidence"]:checked').value;
            const emotion = document.querySelector('input[name="emotion"]:checked').value;
            const voiceEngagement = document.querySelector('input[name="voice_engagement"]:checked').value;
            const gameUnderstanding = document.querySelector('input[name="game_understanding"]:checked').value;
            
            // Prepare report data
            const reportData = {
                systemReport: systemReport.textContent,
                userReport: userReport.value,
                rating: rating,
                detailedResponses: {
                    vocabulary,
                    expression,
                    confidence,
                    emotion,
                    voiceEngagement,
                    gameUnderstanding
                },
                gameMetrics: {
                    gameType: gameSessionData.gameType,
                    gameName: gameSessionData.gameName,
                    duration: Math.round((gameSessionData.endTime - gameSessionData.startTime) / 60000),
                    messageCount: gameSessionData.messageCount,
                    completionStatus: gameSessionData.gameComplete ? "完了" : "未完了",
                    avgMessageLength: gameSessionData.userMessages.length > 0 
                        ? Math.round(gameSessionData.userMessages.join('').length / gameSessionData.userMessages.length) 
                        : 0
                },
                interactions: gameSessionData.interactions,
                email: "kinoshitakai0731@gmail.com",
                timestamp: new Date().toISOString(),
                sessionId: Date.now().toString(),
                sessionType: "game",
                gameName: gameSessionData.gameName
            };
            
            try {
                // Send report to server
                const response = await fetch('/api/send-report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(reportData)
                });
                
                if (response.ok) {
                    alert('レポートが正常に送信されました。ありがとうございます！');
                } else {
                    alert('レポートの送信中にエラーが発生しました。');
                }
                
                // Close modal
                reportModal.classList.add('hidden');
                
                // Reset for a new session if user wants to continue
                resetGame();
            } catch (error) {
                console.error('Error sending report:', error);
                alert('レポートの送信中にエラーが発生しました。');
            }
        });

        // Handle record button clicks
        recordButton.addEventListener('click', function() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        });

        function startRecording() {
            audioChunks = [];
            mediaRecorder.start();
            isRecording = true;
            recordButton.classList.add('recording-animation');
            statusDiv.textContent = '録音中... もう一度クリックすると停止します';
        }

        function stopRecording() {
            mediaRecorder.stop();
            isRecording = false;
            recordButton.classList.remove('recording-animation');
        }

        function addMessage(text, isUser = false) {
            const messagesDiv = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;
            
            messageDiv.innerHTML = `
                <div class="max-w-xs lg:max-w-md ${isUser ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-800'} rounded-lg px-4 py-2">
                    <p class="text-sm">${text}</p>
                </div>
            `;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Initialize game description and progress UI
        window.onload = function() {
            console.log("Window loaded, initializing guided game...");
            
            // Make sure character and emotion are set
            if (!characterSelect.value) {
                characterSelect.value = "2"; // Default to ずんだもん
            }
            
            if (!emotionSelect.value) {
                emotionSelect.value = "energetic"; // Default to energetic
            }
            
            console.log("Selected character:", characterSelect.value);
            console.log("Selected emotion:", emotionSelect.value);
            
            // Initialize game description
            gameSelect.dispatchEvent(new Event('change'));
            
            // Initialize progress UI
            updateGameProgressUI();
            
            // Setup audio recording
            setupAudioRecording();
            
            console.log("Guided game initialization complete");
        };
    </script>
</body>
</html> 